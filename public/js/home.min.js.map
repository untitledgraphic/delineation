{"version":3,"sources":["scrollFX.js","app.js","jquery.lazy.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"home.min.js","sourcesContent":["jQuery(document).ready(function($){\n\t//variables\n\tvar hijacking= $('body').data('hijacking'),\n\t\tanimationType = $('body').data('animation'),\n\t\tdelta = 0,\n        scrollThreshold = 5,\n        actual = 1,\n        animating = false;\n    \n    //DOM elements\n    var sectionsAvailable = $('.feature'),\n        prevArrow = $('.cd-prev'),\n        nextArrow = $('.cd-next');\n\n\t\n\t//check the media query and bind corresponding events\n\tvar MQ = deviceType(),\n\t\tbindToggle = false;\n\t\n\tbindEvents(MQ, true);\n\t\n\t$(window).on('resize', function(){\n\t\tMQ = deviceType();\n\t\tbindEvents(MQ, bindToggle);\n\t\tif( MQ == 'mobile' ) bindToggle = true;\n\t\tif( MQ == 'desktop' ) bindToggle = false;\n\t});\n\n    function bindEvents(MQ, bool) {\n    \t\n    \tif( MQ == 'desktop' && bool) {   \t\t\n    \t\t//bind the animation to the window scroll event, arrows click and keyboard\n\t\t\tif( hijacking == 'on' ) {\n\t\t\t\tinitHijacking();\n\t\t\t\t$(window).on('DOMMouseScroll mousewheel', scrollHijacking);\n\t\t\t} else {\n\t\t\t\tscrollAnimation();\n\t\t\t\t$(window).on('scroll', scrollAnimation);\n\t\t\t}\n\t\t\tprevArrow.on('click', prevSection);\n    \t\tnextArrow.on('click', nextSection);\n            \n\t\t\t//set navigation arrows visibility\n\t\t\tcheckNavigation();\n\t\t} else if( MQ == 'mobile' ) {\n\t\t\t//reset and unbind\n\t\t\tresetSectionStyle();\n\t\t\t$(window).off('DOMMouseScroll mousewheel', scrollHijacking);\n\t\t\t$(window).off('scroll', scrollAnimation);\n\t\t\tprevArrow.off('click', prevSection);\n    \t\tnextArrow.off('click', nextSection);\n    \t\t$(document).off('keydown');\n\t\t}\n    }\n\n\tfunction scrollAnimation(){\n\t\t//normal scroll - use requestAnimationFrame (if defined) to optimize performance\n\t\t(!window.requestAnimationFrame) ? animateSection() : window.requestAnimationFrame(animateSection);\n\t}\n\n\tfunction animateSection() {\n\t\tvar scrollTop = $(window).scrollTop(),\n\t\t\twindowHeight = $(window).height(),\n\t\t\twindowWidth = $(window).width();\n\t\t\n\t\tsectionsAvailable.each(function(){\n\t\t\tvar actualBlock = $(this),\n\t\t\t\toffset = scrollTop - actualBlock.offset().top;\n\n\t\t\t//according to animation type and window scroll, define animation parameters\n\t\t\tvar animationValues = setSectionAnimation(offset, windowHeight, animationType);\n\t\t\t\n\t\t\ttransformSection(actualBlock.children('div'), animationValues[0], animationValues[1], animationValues[2], animationValues[3], animationValues[4]);\n\t\t\t( offset >= 0 && offset < windowHeight ) ? actualBlock.addClass('visible') : actualBlock.removeClass('visible');\t\t\n\t\t});\n\t\t\n\t\tcheckNavigation();\n\t}\n\n\tfunction transformSection(element, translateY, scaleValue, rotateXValue, opacityValue, boxShadow) {\n\t\t//transform sections - normal scroll\n\t\telement.velocity({\n\t\t\ttranslateY: translateY+'vh',\n\t\t\tscale: scaleValue,\n\t\t\trotateX: rotateXValue,\n\t\t\topacity: opacityValue,\n\t\t\tboxShadowBlur: boxShadow+'px',\n\t\t\ttranslateZ: 0,\n\t\t}, 0);\n\t}\n\n\tfunction initHijacking() {\n\t\t// initialize section style - scrollhijacking\n\t\tvar visibleSection = sectionsAvailable.filter('.visible'),\n\t\t\ttopSection = visibleSection.prevAll('.feature'),\n\t\t\tbottomSection = visibleSection.nextAll('.feature'),\n\t\t\tanimationParams = selectAnimation(animationType, false),\n\t\t\tanimationVisible = animationParams[0],\n\t\t\tanimationTop = animationParams[1],\n\t\t\tanimationBottom = animationParams[2];\n\n\t\tvisibleSection.children('div').velocity(animationVisible, 1, function(){\n\t\t\tvisibleSection.css('opacity', 1);\n\t    \ttopSection.css('opacity', 1);\n\t    \tbottomSection.css('opacity', 1);\n\t\t});\n        topSection.children('div').velocity(animationTop, 0);\n        bottomSection.children('div').velocity(animationBottom, 0);\n\t}\n\n\tfunction scrollHijacking (event) {\n\t\t// on mouse scroll - check if animate section\n        if (event.originalEvent.detail < 0 || event.originalEvent.wheelDelta > 0) { \n            delta--;\n            ( Math.abs(delta) >= scrollThreshold) && prevSection();\n        } else {\n            delta++;\n            (delta >= scrollThreshold) && nextSection();\n        }\n        return false;\n    }\n\n    function prevSection(event) {\n    \t//go to previous section\n    \t\n    \tvar visibleSection = sectionsAvailable.filter('.visible'),\n    \t\tmiddleScroll = ( hijacking == 'off' && $(window).scrollTop() != visibleSection.offset().top) ? true : false;\n    \tvisibleSection = middleScroll ? visibleSection.next('.feature') : visibleSection;\n\n    \tvar animationParams = selectAnimation(animationType, middleScroll, 'prev');\n    \tunbindScroll(visibleSection.prev('.feature'), animationParams[3]);\n\n        if( !animating && !visibleSection.is(\":first-child\") ) {\n        \tanimating = true;\n            visibleSection.removeClass('visible').children('div').velocity(animationParams[2], animationParams[3], animationParams[4])\n            .end().prev('.feature').addClass('visible').children('div').velocity(animationParams[0] , animationParams[3], animationParams[4], function(){\n            \tanimating = false;\n            \tif( hijacking == 'off') $(window).on('scroll', scrollAnimation);\n            });\n            \n            actual = actual - 1;\n        }\n\n        resetScroll();\n    }\n\n    function nextSection(event) {\n    \t//go to next section\n\n        var visibleSection = sectionsAvailable.filter('.visible'),\n    \t\tmiddleScroll = ( hijacking == 'off' && $(window).scrollTop() != visibleSection.offset().top) ? true : false;\n\n    \tvar animationParams = selectAnimation(animationType, middleScroll, 'next');\n    \tunbindScroll(visibleSection.next('.feature'), animationParams[3]);\n\n        if(!animating && !visibleSection.is(\":last-of-type\") ) {\n            animating = true;\n            visibleSection.removeClass('visible').children('div').velocity(animationParams[1], animationParams[3], animationParams[4] )\n            .end().next('.feature').addClass('visible').children('div').velocity(animationParams[0], animationParams[3], animationParams[4], function(){\n            \tanimating = false;\n            \tif( hijacking == 'off') $(window).on('scroll', scrollAnimation);\n            });\n\n            actual = actual +1;\n        }\n        resetScroll();\n    }\n\n    function unbindScroll(section, time) {\n    \t//if clicking on navigation - unbind scroll and animate using custom velocity animation\n    \tif( hijacking == 'off') {\n    \t\t$(window).off('scroll', scrollAnimation);\n    \t\t( animationType == 'catch') ? $('body, html').scrollTop(section.offset().top) : section.velocity(\"scroll\", { duration: time });\n    \t}\n    }\n\n    function resetScroll() {\n        delta = 0;\n        checkNavigation();\n    }\n\n    function checkNavigation() {\n    \t//update navigation arrows visibility\n\t\t( sectionsAvailable.filter('.visible').is(':first-of-type') ) ? prevArrow.addClass('inactive') : prevArrow.removeClass('inactive');\n\t\t( sectionsAvailable.filter('.visible').is(':last-of-type')  ) ? nextArrow.addClass('inactive') : nextArrow.removeClass('inactive');\n\t}\n\n\tfunction resetSectionStyle() {\n\t\t//on mobile - remove style applied with jQuery\n\t\tsectionsAvailable.children('div').each(function(){\n\t\t\t$(this).attr('style', '');\n\t\t});\n\t}\n\n\tfunction deviceType() {\n\t\t//detect if desktop/mobile\n\t\treturn window.getComputedStyle(document.querySelector('body'), '::before').getPropertyValue('content').replace(/\"/g, \"\").replace(/'/g, \"\");\n\t}\n\n\tfunction selectAnimation(animationName, middleScroll, direction) {\n\t\t// select section animation - scrollhijacking\n\t\tvar animationVisible = 'translateNone',\n\t\t\tanimationTop = 'translateUp',\n\t\t\tanimationBottom = 'translateDown',\n\t\t\teasing = 'ease',\n\t\t\tanimDuration = 800;\n\n\t\treturn [animationVisible, animationTop, animationBottom, animDuration, easing];\n\t}\n\n\tfunction setSectionAnimation(sectionOffset, windowHeight, animationName ) {\n\t\t// select section animation - normal scroll\n\t\tvar scale = 1,\n\t\t\ttranslateY = 100,\n\t\t\trotateX = '0deg',\n\t\t\topacity = 1,\n\t\t\tboxShadowBlur = 0;\n\n\t\treturn [translateY, scale, rotateX, opacity, boxShadowBlur]; \n\t}\n});\n\n/* Custom effects registration - feature available in the Velocity UI pack */\n//none\n$.Velocity.RegisterEffect(\"translateUp\", {\n    defaultDuration: 1,\n    calls: [ \n        [ { translateY: '-100%'}, 1]\n    ]\n});\n$.Velocity.RegisterEffect(\"translateDown\", {\n    defaultDuration: 1,\n    calls: [ \n        [ { translateY: '100%'}, 1]\n    ]\n});\n$.Velocity.RegisterEffect(\"translateNone\", {\n    defaultDuration: 1,\n    calls: [ \n        [ { \n            translateY: '0', \n            opacity: '1', \n            scale: '1', \n            rotateX: '0', \n            boxShadowBlur: '0'}, 1]\n    ]\n});\n\n","/*! (c) 2018 Craig Cooper */\n\nvar app = (function ($) {\n    'use strict';\n\n    // private alias to settings\n    //var s;\n\n    return {\n        settings: function () {\n            this.$window        = $(window);\n        },\n\n        init: function () {\n            //var s = new this.settings();\n            \n            this.bindUIActions();       // UI Actions (click, focus etc)\n            this.nav();                 // Main navigation\n            this.form();                // form type stuff\n            this.lazy();                // lazyload config\n            this.parallax();            // parallaxy images\n            this.scrollon();            // scroll down a bit\n        },\n\n        bindUIActions: function() {\n            \n            ////////// LOGO DEBOSS ///////////\n            setTimeout(function(){\n                $('body').addClass('loaded');\n            }, 2000);\n        },\n        \n        nav: function() {\n            var nav = '#mainNav';\n            var navon = 'mainNav--active';\n            \n            $('#navTrigger').click(function(e) {\n                e.preventDefault();\n                $(nav).addClass(navon);\n            });\n            $('.mainNav__close').click(function(e) {\n                e.preventDefault();\n                $(nav).removeClass(navon);\n            });\n            $('.mainNav__link').click(function() {\n                $(nav).removeClass(navon);\n            });\n            \n            $('#works').click(function() {\n                \n                var first = '[data-slide=\"1\"]';\n                var active = 'active';\n                \n                if ($(first).hasClass(active)) {\n                    //do nothing\n                }\n                else if ($('.slide').not(first).hasClass(active)) { \n                    $('.slide').not(first).removeClass(active);\n                    $(first).addClass(active);\n                }\n                else {\n                    $(first).addClass(active);\n                }\n            });\n        },\n        \n        scrollon: function() {\n            \n            var scrollTrigger = function() {\n                $('#helper').on('click', function(e) {\n                    e.preventDefault(); \n\n                    var scrollPos = $(document).scrollTop();\n\n                    $('html, body').animate({ \n                        scrollTop: $(window).height() + scrollPos  //Get the document height\n                    }, 'slow'); //Animates the scroll\n                });\n            };\n        \n            $(window).on('load resize', function() {\n                \n                if (window.location.href !== 'http://localhost:3000/') {\n                    scrollTrigger();\n                }\n                else if ($(this).width() < 768) {\n                    scrollTrigger();\n                }\n            });\n        },\n        \n        form: function() {\n            \n            $('.form__txt').blur(function() {\n                var tmpval = $(this).val();\n                if(tmpval === '') {\n//                    $(this).addClass('empty');\n                    $(this).removeClass('filled');\n                } else {\n                    $(this).addClass('filled');\n//                    $(this).removeClass('empty');\n                }\n            });\n        },\n        \n        lazy: function() {\n\n            $('.lazy').Lazy({\n                // your configuration goes here\n                scrollDirection: 'vertical',\n                effect: 'fadeIn',\n                effectTime: 1000,\n                visibleOnly: true,\n                //onError: function(element) {\n                    //console.log('error loading ' + element.data('src'));\n                //},\n                afterLoad: function() {\n                    $(this).addClass('loadeded');\n                    //console.log('loaded' + e.data('src'));\n                }\n            });\n        },\n        \n        parallax: function() {\n            \n            $( window ).scroll(function() {\n                \n                var scroll = $(window).scrollTop();\n                var h = $( window ).innerHeight()/2;\n                $('.hero img').css('top', scroll/5);\n                $('.hero__banner').css('opacity', 1 - scroll/h);\n            });\n        }\n    };\n})(jQuery);\n\njQuery(document).ready(function() {\n    app.init();\n});","/*!\n * jQuery & Zepto Lazy - v1.7.5\n * http://jquery.eisbehr.de/lazy/\n *\n * Copyright 2012 - 2017, Daniel 'Eisbehr' Kern\n *\n * Dual licensed under the MIT and GPL-2.0 licenses:\n * http://www.opensource.org/licenses/mit-license.php\n * http://www.gnu.org/licenses/gpl-2.0.html\n *\n * $(\"img.lazy\").lazy();\n */\n\n;(function(window, undefined) {\n    \"use strict\";\n\n    // noinspection JSUnresolvedVariable\n    /**\n     * library instance - here and not in construct to be shorter in minimization\n     * @return void\n     */\n    var $ = window.jQuery || window.Zepto,\n\n    /**\n     * unique plugin instance id counter\n     * @type {number}\n     */\n    lazyInstanceId = 0,\n\n    /**\n     * helper to register window load for jQuery 3\n     * @type {boolean}\n     */    \n    windowLoaded = false;\n\n    /**\n     * make lazy available to jquery - and make it a bit more case-insensitive :)\n     * @access public\n     * @type {function}\n     * @param {object} settings\n     * @return void\n     */\n    $.fn.Lazy = $.fn.lazy = function(settings) {\n        return new LazyPlugin(this, settings);\n    };\n\n    /**\n     * helper to add plugins to lazy prototype configuration\n     * @access public\n     * @type {function}\n     * @param {string|Array} names\n     * @param {string|Array} [elements]\n     * @param {function} loader\n     * @return void\n     */\n    $.Lazy = $.lazy = function(names, elements, loader) {\n        // make second parameter optional\n        if( $.isFunction(elements) ) {\n            loader = elements;\n            elements = [];\n        }\n\n        // exit here if parameter is not a callable function\n        if( !$.isFunction(loader) ) return;\n\n        // make parameters an array of names to be sure\n        names = $.isArray(names) ? names : [names];\n        elements = $.isArray(elements) ? elements : [elements];\n\n        var config = LazyPlugin.prototype.config,\n            forced = config._f || (config._f = {});\n\n        // add the loader plugin for every name\n        for( var i = 0, l = names.length; i < l; i++ )\n            if( config[names[i]] === undefined || $.isFunction(config[names[i]]) )\n                config[names[i]] = loader;\n\n        // add forced elements loader\n        for( var c = 0, a = elements.length; c < a; c++ )\n            forced[elements[c]] = names[0];\n    };\n\n    /**\n     * contains all logic and the whole element handling\n     * is packed in a private function outside class to reduce memory usage, because it will not be created on every plugin instance\n     * @access private\n     * @type {function}\n     * @param {LazyPlugin} instance\n     * @param {object} config\n     * @param {object|Array} items\n     * @param {object} events\n     * @param {string} namespace\n     * @return void\n     */\n    function _executeLazy(instance, config, items, events, namespace) {\n        /**\n         * a helper to trigger the 'onFinishedAll' callback after all other events\n         * @access private\n         * @type {number}\n         */\n        var _awaitingAfterLoad = 0,\n\n        /**\n         * visible content width\n         * @access private\n         * @type {number}\n         */\n        _actualWidth = -1,\n\n        /**\n         * visible content height\n         * @access private\n         * @type {number}\n         */\n        _actualHeight = -1,\n\n        /**\n         * determine possibly detected high pixel density\n         * @access private\n         * @type {boolean}\n         */\n        _isRetinaDisplay = false, \n\n        /**\n         * dictionary entry for better minimization\n         * @access private\n         * @type {string}\n         */\n        _afterLoad = \"afterLoad\",\n\n        /**\n         * dictionary entry for better minimization\n         * @access private\n         * @type {string}\n         */\n        _load = \"load\",\n\n        /**\n         * dictionary entry for better minimization\n         * @access private\n         * @type {string}\n         */\n        _error = \"error\",\n\n        /**\n         * dictionary entry for better minimization\n         * @access private\n         * @type {string}\n         */\n        _img = \"img\",\n\n        /**\n         * dictionary entry for better minimization\n         * @access private\n         * @type {string}\n         */\n        _src = \"src\",\n\n        /**\n         * dictionary entry for better minimization\n         * @access private\n         * @type {string}\n         */\n        _srcset = \"srcset\",\n\n        /**\n         * dictionary entry for better minimization\n         * @access private\n         * @type {string}\n         */\n        _sizes = \"sizes\",\n\n        /**\n         * dictionary entry for better minimization\n         * @access private\n         * @type {string}\n         */\n        _backgroundImage = \"background-image\";\n\n        /**\n         * initialize plugin\n         * bind loading to events or set delay time to load all items at once\n         * @access private\n         * @return void\n         */\n        function _initialize() {\n            // detect actual device pixel ratio\n            // noinspection JSUnresolvedVariable\n            _isRetinaDisplay = window.devicePixelRatio > 1;\n\n            // prepare all initial items\n            _prepareItems(items);\n\n            // if delay time is set load all items at once after delay time\n            if( config.delay >= 0 ) setTimeout(function() { _lazyLoadItems(true); }, config.delay);\n\n            // if no delay is set or combine usage is active bind events\n            if( config.delay < 0 || config.combined ) {\n                // create unique event function\n                events.e = _throttle(config.throttle, function(event) {\n                    // reset detected window size on resize event\n                    if( event.type === \"resize\" )\n                        _actualWidth = _actualHeight = -1;\n\n                    // execute 'lazy magic'\n                    _lazyLoadItems(event.all);\n                });\n\n                // create function to add new items to instance\n                events.a = function(additionalItems) {\n                    _prepareItems(additionalItems);\n                    items.push.apply(items, additionalItems);\n                };\n\n                // create function to get all instance items left\n                events.g = function() {\n                    // filter loaded items before return in case internal filter was not running until now\n                    return (items = $(items).filter(function() {\n                        return !$(this).data(config.loadedName);\n                    }));\n                };\n\n                // create function to force loading elements\n                events.f = function(forcedItems) {\n                    for( var i = 0; i < forcedItems.length; i++ ) {\n                        // only handle item if available in current instance\n                        // use a compare function, because Zepto can't handle object parameter for filter\n                        // var item = items.filter(forcedItems[i]);\n                        /* jshint loopfunc: true */\n                        var item = items.filter(function() {\n                            return this === forcedItems[i];\n                        });\n\n                        if( item.length ) {\n                            _lazyLoadItems(false, item);   \n                        }\n                    }\n                };\n\n                // load initial items\n                _lazyLoadItems();\n\n                // bind lazy load functions to scroll and resize event\n                // noinspection JSUnresolvedVariable\n                $(config.appendScroll).on(\"scroll.\" + namespace + \" resize.\" + namespace, events.e);\n            }\n        }\n\n        /**\n         * prepare items before handle them\n         * @access private\n         * @param {Array|object|jQuery} items\n         * @return void\n         */\n        function _prepareItems(items) {\n            // fetch used configurations before loops\n            var defaultImage = config.defaultImage,\n                placeholder = config.placeholder,\n                imageBase = config.imageBase,\n                srcsetAttribute = config.srcsetAttribute,\n                loaderAttribute = config.loaderAttribute,\n                forcedTags = config._f || {};\n\n            // filter items and only add those who not handled yet and got needed attributes available\n            items = $(items).filter(function() {\n                var element = $(this),\n                    tag = _getElementTagName(this);\n\n                return !element.data(config.handledName) && \n                       (element.attr(config.attribute) || element.attr(srcsetAttribute) || element.attr(loaderAttribute) || forcedTags[tag] !== undefined);\n            })\n\n            // append plugin instance to all elements\n            .data(\"plugin_\" + config.name, instance);\n\n            for( var i = 0, l = items.length; i < l; i++ ) {\n                var element = $(items[i]),\n                    tag = _getElementTagName(items[i]),\n                    elementImageBase = element.attr(config.imageBaseAttribute) || imageBase;\n\n                // generate and update source set if an image base is set\n                if( tag === _img && elementImageBase && element.attr(srcsetAttribute) )\n                    element.attr(srcsetAttribute, _getCorrectedSrcSet(element.attr(srcsetAttribute), elementImageBase));\n\n                // add loader to forced element types\n                if( forcedTags[tag] !== undefined && !element.attr(loaderAttribute) )\n                    element.attr(loaderAttribute, forcedTags[tag]);\n\n                // set default image on every element without source\n                if( tag === _img && defaultImage && !element.attr(_src) )\n                    element.attr(_src, defaultImage);\n\n                // set placeholder on every element without background image\n                else if( tag !== _img && placeholder && (!element.css(_backgroundImage) || element.css(_backgroundImage) === \"none\") )\n                    element.css(_backgroundImage, \"url('\" + placeholder + \"')\");\n            }\n        }\n\n        /**\n         * the 'lazy magic' - check all items\n         * @access private\n         * @param {boolean} [allItems]\n         * @param {object} [forced]\n         * @return void\n         */\n        function _lazyLoadItems(allItems, forced) {\n            // skip if no items where left\n            if( !items.length ) {\n                // destroy instance if option is enabled\n                if( config.autoDestroy )\n                    // noinspection JSUnresolvedFunction\n                    instance.destroy();\n\n                return;\n            }\n\n            var elements = forced || items,\n                loadTriggered = false,\n                imageBase = config.imageBase || \"\",\n                srcsetAttribute = config.srcsetAttribute,\n                handledName = config.handledName;\n\n            // loop all available items\n            for( var i = 0; i < elements.length; i++ ) {\n                // item is at least in loadable area\n                if( allItems || forced || _isInLoadableArea(elements[i]) ) {\n                    var element = $(elements[i]),\n                        tag = _getElementTagName(elements[i]),\n                        attribute = element.attr(config.attribute),\n                        elementImageBase = element.attr(config.imageBaseAttribute) || imageBase,\n                        customLoader = element.attr(config.loaderAttribute);\n\n                        // is not already handled \n                    if( !element.data(handledName) &&\n                        // and is visible or visibility doesn't matter\n                        (!config.visibleOnly || element.is(\":visible\")) && (\n                        // and image source or source set attribute is available\n                        (attribute || element.attr(srcsetAttribute)) && (\n                            // and is image tag where attribute is not equal source or source set\n                            (tag === _img && (elementImageBase + attribute !== element.attr(_src) || element.attr(srcsetAttribute) !== element.attr(_srcset))) ||\n                            // or is non image tag where attribute is not equal background\n                            (tag !== _img && elementImageBase + attribute !== element.css(_backgroundImage)) \n                        ) ||\n                        // or custom loader is available\n                        customLoader ))\n                    {\n                        // mark element always as handled as this point to prevent double handling\n                        loadTriggered = true;\n                        element.data(handledName, true);\n\n                        // load item\n                        _handleItem(element, tag, elementImageBase, customLoader);\n                    }\n                }\n            }\n\n            // when something was loaded remove them from remaining items\n            if( loadTriggered )\n                items = $(items).filter(function() {\n                    return !$(this).data(handledName);\n                });\n        }\n\n        /**\n         * load the given element the lazy way\n         * @access private\n         * @param {object} element\n         * @param {string} tag\n         * @param {string} imageBase\n         * @param {function} [customLoader]\n         * @return void\n         */\n        function _handleItem(element, tag, imageBase, customLoader) {\n            // increment count of items waiting for after load\n            ++_awaitingAfterLoad;\n\n            // extended error callback for correct 'onFinishedAll' handling\n            var errorCallback = function() {\n                _triggerCallback(\"onError\", element);\n                _reduceAwaiting();\n\n                // prevent further callback calls\n                errorCallback = $.noop;\n            };\n\n            // trigger function before loading image\n            _triggerCallback(\"beforeLoad\", element);\n\n            // fetch all double used data here for better code minimization\n            var srcAttribute = config.attribute,\n                srcsetAttribute = config.srcsetAttribute,\n                sizesAttribute = config.sizesAttribute,\n                retinaAttribute = config.retinaAttribute,\n                removeAttribute = config.removeAttribute,\n                loadedName = config.loadedName,\n                elementRetina = element.attr(retinaAttribute);\n\n            // handle custom loader\n            if( customLoader ) {\n                // on load callback\n                var loadCallback = function() {\n                    // remove attribute from element\n                    if( removeAttribute )\n                        element.removeAttr(config.loaderAttribute);\n\n                    // mark element as loaded\n                    element.data(loadedName, true);\n\n                    // call after load event\n                    _triggerCallback(_afterLoad, element);\n\n                    // remove item from waiting queue and possibly trigger finished event\n                    // it's needed to be asynchronous to run after filter was in _lazyLoadItems\n                    setTimeout(_reduceAwaiting, 1);\n\n                    // prevent further callback calls\n                    loadCallback = $.noop;\n                };\n\n                // bind error event to trigger callback and reduce waiting amount\n                element.off(_error).one(_error, errorCallback)\n\n                // bind after load callback to element\n                .one(_load, loadCallback);\n\n                // trigger custom loader and handle response\n                if( !_triggerCallback(customLoader, element, function(response) {\n                    if( response ) {\n                        element.off(_load);\n                        loadCallback();\n                    }\n                    else {\n                        element.off(_error);\n                        errorCallback();\n                    }\n                })) element.trigger(_error);\n            }\n\n            // handle images\n            else {\n                // create image object\n                var imageObj = $(new Image());\n\n                // bind error event to trigger callback and reduce waiting amount\n                imageObj.one(_error, errorCallback)\n\n                // bind after load callback to image\n                .one(_load, function() {\n                    // remove element from view\n                    element.hide();\n\n                    // set image back to element\n                    // do it as single 'attr' calls, to be sure 'src' is set after 'srcset'\n                    if( tag === _img )\n                        element.attr(_sizes, imageObj.attr(_sizes))\n                               .attr(_srcset, imageObj.attr(_srcset))\n                               .attr(_src, imageObj.attr(_src));\n                    else\n                        element.css(_backgroundImage, \"url('\" + imageObj.attr(_src) + \"')\");\n\n                    // bring it back with some effect!\n                    element[config.effect](config.effectTime);\n\n                    // remove attribute from element\n                    if( removeAttribute ) {\n                        element.removeAttr(srcAttribute + \" \" + srcsetAttribute + \" \" + retinaAttribute + \" \" + config.imageBaseAttribute);\n\n                        // only remove 'sizes' attribute, if it was a custom one\n                        if( sizesAttribute !== _sizes )\n                            element.removeAttr(sizesAttribute);\n                    }\n\n                    // mark element as loaded\n                    element.data(loadedName, true);\n\n                    // call after load event\n                    _triggerCallback(_afterLoad, element);\n\n                    // cleanup image object\n                    imageObj.remove();\n\n                    // remove item from waiting queue and possibly trigger finished event\n                    _reduceAwaiting();\n                });\n\n                // set sources\n                // do it as single 'attr' calls, to be sure 'src' is set after 'srcset'\n                var imageSrc = (_isRetinaDisplay && elementRetina ? elementRetina : element.attr(srcAttribute)) || \"\";\n                imageObj.attr(_sizes, element.attr(sizesAttribute))\n                        .attr(_srcset, element.attr(srcsetAttribute))\n                        .attr(_src, imageSrc ? imageBase + imageSrc : null);\n\n                // call after load even on cached image\n                imageObj.complete && imageObj.trigger(_load); // jshint ignore : line\n            }\n        }\n\n        /**\n         * check if the given element is inside the current viewport or threshold\n         * @access private\n         * @param {object} element\n         * @return {boolean}\n         */\n        function _isInLoadableArea(element) {\n            var elementBound = element.getBoundingClientRect(),\n                direction    = config.scrollDirection,\n                threshold    = config.threshold,\n                vertical     = // check if element is in loadable area from top\n                               ((_getActualHeight() + threshold) > elementBound.top) &&\n                               // check if element is even in loadable are from bottom\n                               (-threshold < elementBound.bottom),\n                horizontal   = // check if element is in loadable area from left\n                               ((_getActualWidth() + threshold) > elementBound.left) &&\n                               // check if element is even in loadable area from right\n                               (-threshold < elementBound.right);\n\n            if( direction === \"vertical\" ) return vertical;\n            else if( direction === \"horizontal\" ) return horizontal;\n\n            return vertical && horizontal;\n        }\n\n        /**\n         * receive the current viewed width of the browser\n         * @access private\n         * @return {number}\n         */\n        function _getActualWidth() {\n            return _actualWidth >= 0 ? _actualWidth : (_actualWidth = $(window).width());\n        }\n\n        /**\n         * receive the current viewed height of the browser\n         * @access private\n         * @return {number}\n         */\n        function _getActualHeight() {\n            return _actualHeight >= 0 ? _actualHeight : (_actualHeight = $(window).height());\n        }\n\n        /**\n         * get lowercase tag name of an element\n         * @access private\n         * @param {object} element\n         * @returns {string}\n         */\n        function _getElementTagName(element) {\n            return element.tagName.toLowerCase();\n        }\n\n        /**\n         * prepend image base to all srcset entries\n         * @access private\n         * @param {string} srcset\n         * @param {string} imageBase\n         * @returns {string}\n         */\n        function _getCorrectedSrcSet(srcset, imageBase) {\n            if( imageBase ) {\n                // trim, remove unnecessary spaces and split entries\n                var entries = srcset.split(\",\");\n                srcset = \"\";\n\n                for( var i = 0, l = entries.length; i < l; i++ )\n                    srcset += imageBase + entries[i].trim() + (i !== l - 1 ? \",\" : \"\");\n            }\n\n            return srcset;\n        }\n\n        /**\n         * helper function to throttle down event triggering\n         * @access private\n         * @param {number} delay\n         * @param {function} callback\n         * @return {function}\n         */\n        function _throttle(delay, callback) {\n            var timeout,\n                lastExecute = 0;\n\n            return function(event, ignoreThrottle) {\n                var elapsed = +new Date() - lastExecute;\n\n                function run() {\n                    lastExecute = +new Date();\n                    callback.call(instance, event);\n                }\n\n                timeout && clearTimeout(timeout); // jshint ignore : line\n\n                if( elapsed > delay || !config.enableThrottle || ignoreThrottle ) run();\n                else timeout = setTimeout(run, delay - elapsed);\n            };\n        }\n\n        /**\n         * reduce count of awaiting elements to 'afterLoad' event and fire 'onFinishedAll' if reached zero\n         * @access private\n         * @return void\n         */\n        function _reduceAwaiting() {\n            --_awaitingAfterLoad;\n\n            // if no items were left trigger finished event\n            if( !items.length && !_awaitingAfterLoad ) _triggerCallback(\"onFinishedAll\");\n        }\n\n        /**\n         * single implementation to handle callbacks, pass element and set 'this' to current instance\n         * @access private\n         * @param {string|function} callback\n         * @param {object} [element]\n         * @param {*} [args]\n         * @return {boolean}\n         */\n        function _triggerCallback(callback, element, args) {\n            if( (callback = config[callback]) ) {\n                // jQuery's internal '$(arguments).slice(1)' are causing problems at least on old iPads\n                // below is shorthand of 'Array.prototype.slice.call(arguments, 1)'\n                callback.apply(instance, [].slice.call(arguments, 1));\n                return true;\n            }\n\n            return false;\n        }\n\n        // if event driven or window is already loaded don't wait for page loading\n        if( config.bind === \"event\" || windowLoaded )\n            _initialize();\n\n        // otherwise load initial items and start lazy after page load\n        else // noinspection JSUnresolvedVariable\n            $(window).on(_load + \".\" + namespace, _initialize);\n    }\n\n    /**\n     * lazy plugin class constructor\n     * @constructor\n     * @access private\n     * @param {object} elements\n     * @param {object} settings\n     * @return {object|LazyPlugin}\n     */\n    function LazyPlugin(elements, settings) {\n        /**\n         * this lazy plugin instance\n         * @access private\n         * @type {object|LazyPlugin|LazyPlugin.prototype}\n         */\n        var _instance = this,\n\n        /**\n         * this lazy plugin instance configuration\n         * @access private\n         * @type {object}\n         */\n        _config = $.extend({}, _instance.config, settings),\n\n        /**\n         * instance generated event executed on container scroll or resize\n         * packed in an object to be referenceable and short named because properties will not be minified\n         * @access private\n         * @type {object}\n         */\n        _events = {},\n\n        /**\n         * unique namespace for instance related events\n         * @access private\n         * @type {string}\n         */\n        _namespace = _config.name + \"-\" + (++lazyInstanceId);\n\n        // noinspection JSUndefinedPropertyAssignment\n        /**\n         * wrapper to get or set an entry from plugin instance configuration\n         * much smaller on minify as direct access\n         * @access public\n         * @type {function}\n         * @param {string} entryName\n         * @param {*} [value]\n         * @return {LazyPlugin|*}\n         */\n        _instance.config = function(entryName, value) {\n            if( value === undefined )\n                return _config[entryName];\n\n            _config[entryName] = value;\n            return _instance;\n        };\n\n        // noinspection JSUndefinedPropertyAssignment\n        /**\n         * add additional items to current instance\n         * @access public\n         * @param {Array|object|string} items\n         * @return {LazyPlugin}\n         */\n        _instance.addItems = function(items) {\n            _events.a && _events.a($.type(items) === \"string\" ? $(items) : items); // jshint ignore : line\n            return _instance;\n        };\n\n        // noinspection JSUndefinedPropertyAssignment\n        /**\n         * get all left items of this instance\n         * @access public\n         * @returns {object}\n         */\n        _instance.getItems = function() {\n            return _events.g ? _events.g() : {};\n        };\n\n        // noinspection JSUndefinedPropertyAssignment\n        /**\n         * force lazy to load all items in loadable area right now\n         * by default without throttle\n         * @access public\n         * @type {function}\n         * @param {boolean} [useThrottle]\n         * @return {LazyPlugin}\n         */\n        _instance.update = function(useThrottle) {\n            _events.e && _events.e({}, !useThrottle); // jshint ignore : line\n            return _instance;\n        };\n\n        // noinspection JSUndefinedPropertyAssignment\n        /**\n         * force element(s) to load directly, ignoring the viewport\n         * @access public\n         * @param {Array|object|string} items\n         * @return {LazyPlugin}\n         */\n        _instance.force = function(items) {\n            _events.f && _events.f($.type(items) === \"string\" ? $(items) : items); // jshint ignore : line\n            return _instance;\n        };\n\n        // noinspection JSUndefinedPropertyAssignment\n        /**\n         * force lazy to load all available items right now\n         * this call ignores throttling\n         * @access public\n         * @type {function}\n         * @return {LazyPlugin}\n         */\n        _instance.loadAll = function() {\n            _events.e && _events.e({all: true}, true); // jshint ignore : line\n            return _instance;\n        };\n\n        // noinspection JSUndefinedPropertyAssignment\n        /**\n         * destroy this plugin instance\n         * @access public\n         * @type {function}\n         * @return undefined\n         */\n        _instance.destroy = function() {\n            // unbind instance generated events\n            // noinspection JSUnresolvedFunction, JSUnresolvedVariable\n            $(_config.appendScroll).off(\".\" + _namespace, _events.e);\n            // noinspection JSUnresolvedVariable\n            $(window).off(\".\" + _namespace);\n\n            // clear events\n            _events = {};\n\n            return undefined;\n        };\n\n        // start using lazy and return all elements to be chainable or instance for further use\n        // noinspection JSUnresolvedVariable\n        _executeLazy(_instance, _config, elements, _events, _namespace);\n        return _config.chainable ? elements : _instance;\n    }\n\n    /**\n     * settings and configuration data\n     * @access public\n     * @type {object}\n     */\n    LazyPlugin.prototype.config = {\n        // general\n        name               : \"lazy\",\n        chainable          : true,\n        autoDestroy        : true,\n        bind               : \"load\",\n        threshold          : 500,\n        visibleOnly        : false,\n        appendScroll       : window,\n        scrollDirection    : \"both\",\n        imageBase          : null,\n        defaultImage       : \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\",\n        placeholder        : null,\n        delay              : -1,\n        combined           : false,\n\n        // attributes\n        attribute          : \"data-src\",\n        srcsetAttribute    : \"data-srcset\",\n        sizesAttribute     : \"data-sizes\",\n        retinaAttribute    : \"data-retina\",\n        loaderAttribute    : \"data-loader\",\n        imageBaseAttribute : \"data-imagebase\",\n        removeAttribute    : true,\n        handledName        : \"handled\",\n        loadedName         : \"loaded\",\n\n        // effect\n        effect             : \"show\",\n        effectTime         : 0,\n\n        // throttle\n        enableThrottle     : true,\n        throttle           : 250,\n\n        // callbacks\n        beforeLoad         : undefined,\n        afterLoad          : undefined,\n        onError            : undefined,\n        onFinishedAll      : undefined\n    };\n\n    // register window load event globally to prevent not loading elements\n    // since jQuery 3.X ready state is fully async and may be executed after 'load' \n    $(window).on(\"load\", function() { windowLoaded = true; });\n})(window);"]}